global Inst {
  const ADD = 6b000000; // Partial, need to implement z
  const SUB = 6b000001; // Partial, need to implement z
  const MUL = 6b000010; // Works
  const DIV = 6b000011; // Undone
  const AND = 6b011000; // Works
  const OR = 6b011110; // Works
  const XOR = 6b010110; // Works
  const LDR = 6b011010; // Undone
  const INV = 6b010001; // Works
  const SHL = 6b100000; // Works
  const SHR = 6b100001; // Works
  const SRA = 6b100011; // Undone
  const CMPEQ = 6b110011; // Works
  const CMPLT = 6b110101; // Works
  const CMPLE = 6b110111; // Works
}

module alu (
    input clk,  // clock
    input rst,  // reset
    input alufn[6],
    input op1[8],
    input op2[8],
    input z,
    input v,
    input n,
    output out[8],
    output zOut,
    output vOut,
    output nOut
  ) {
  
  sig result[8];
  
  always {
    zOut = 0;
    vOut = 0;
    nOut = 0;
    out = 8hxx;
    
    case(alufn) {
      Inst.ADD:
        result = op1 + op2;
        out = result;
        nOut = result[7];
        vOut = (op1[7] & op2[7] & ~result[7]) | (~op1[7] & ~op2[7] & result[7]);
        // TODO: zOut
      Inst.SUB:
        result = op1 - op2;
        out = result;
        nOut = result[7];
        vOut = (op1[7] & op2[7] & ~result[7]) | (~op1[7] & ~op2[7] & result[7]);
        // TODO: zOut
      Inst.MUL:
        out = op1 * op2;
      Inst.AND:
        out = op1 & op2;
      Inst.OR:
        out = op1 | op2;
      Inst.XOR:
        out = op1 ^ op2;
      Inst.INV:
        out = ~op1;
      //Inst.LDR:
        // TODO
      Inst.SHL:
        out = op1 << op2;
      Inst.SHR:
        out = op1 >> op2;
      //Inst.SRA:
        //TODO
      Inst.CMPEQ:
        out = op1 == op2;
      Inst.CMPLT:
        out = op1 < op2;
      Inst.CMPLE:
        out = op1 <= op2;
    }
  }
}