module adder (
    input clk,  // clock
    input rst,  // reset
    input alufn[6],
    input op1[8],
    input op2[8],
    output out[8],
    output zOut,
    output vOut,
    output nOut
  ) {
  
  sig zComp;
  sig result[8];
  var i;
  
  sig shift[4];
  sig amant[4];
  sig bmant[4];
  sig fresult[5];
  sig o1[8];
  sig o2[8];
  
  always {
    zOut = 0;
    vOut = 0;
    nOut = 0;
    out = 8hxx;
    case(alufn) {
      Inst.ADD:
        result = op1 + op2;
        out = result;
        nOut = result[7];
        vOut = (op1[7] & op2[7] & ~result[7]) | (~op1[7] & ~op2[7] & result[7]);
        zComp = result[0];
        for(i = 1; i < 8; i++) {
          zComp = ~(zComp | result[i]);
        }
        zOut = zComp;
      Inst.SUB:
        result = op1 - op2;
        out = result;
        nOut = result[7];
        vOut = (op1[7] & op2[7] & ~result[7]) | (~op1[7] & ~op2[7] & result[7]);
        zComp = result[0];
        for(i = 1; i < 8; i++) {
          zComp = ~(zComp | result[i]);
        }
        zOut = zComp;
      Inst.MUL:
        out = op1 * op2;
      //Inst.DIV:
        //TODO
      Inst.NEG:
        out = -op1;
      Inst.ABS:
        out = (-op1 & 8x{op1[7]}) | (op1 & 8x{~op1[7]});
      Inst.FADD:
        if(op1[6:3] > op2[6:3]) {
          o1 = op1;
          o2 = op2;
        }
        else {
          o1 = op2;
          o2 = op1;
        }
        shift = o1[6:3] - o2[6:3];
        amant[3] = 1;
        amant[2:0] = o1[2:0];
        
        bmant[3] = 1;
        bmant[2:0] = o2[2:0];
        
        bmant = bmant >> shift;
        
        fresult = amant + bmant;
        if(fresult[4] == 1) {
          out[6:3] = o1[6:3] + 1;
          fresult = fresult >> 1;
        }
        else {
          out[6:3] = o1[6:3];
        }
        
        out[2:0] = fresult[2:0];
    }
  }
}
