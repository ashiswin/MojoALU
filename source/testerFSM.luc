module testerFSM (
    input clk,  // clock
    input rst,  // reset
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8],     // DIP switches on IO Shield
    
    output out[8], //output
    output zOut,
    output vOut,
    output nOut,
    output text[4][7]
    
  ) {
  
  .clk(clk), .rst(rst) {
      
    fsm state(#INIT(MANUAL)) = {MANUAL, ADDER1, ADDER2, ADDER3,ADDER4, SUB1, SUB2, SUB3,SUB4, ADDER_ERR, SUB_ERR,
                                        AND1,AND2,AND3,AND_ERR,OR,OR2,OR_ERR,XOR,XOR2,XOR_ERR,INV,INV_ERR,
                                        CMPEQ, CMPLT, CMPLE, EQ_ERR, LT_ERR, LE_ERR,
                                        LDR,LDR_ERR,
                                        SHL, SHR, SRA, SHL2, SHR2, SRA2, SHL_ERR,SHR_ERR, SRA_ERR,
                                        DIV,DIV_ERR,MUL,MUL2,MUL3,MUL_ERR,NEG,NEG_ERR,ABS,ABS2,ABS_ERR
                                        };  
    dff counter[30];    // counter for FSM steps
  }
  alu alu;
  
  const DELAY = 26;// sets a delay to give time for calculations to complete. Lower number = less delay
  
  always {
     
    out = alu.out;
    zOut = alu.zOut;
    vOut = alu.vOut;
    nOut = alu.nOut;
    alu.z = 0;
    alu.n = 0;
    alu.v = 0;
    alu.alufn = 6b0;
    alu.op1 = 8b0;
    alu.op2 = 8b0;
    
    text = {"r","a","u","r"};
   
    case(state.q) {
      
      state.MANUAL:
        alu.alufn = io_dip[0][5:0];
        alu.op1 = io_dip[1];
        alu.op2 = io_dip[2];
        
        text = {7h0, 7h0, 7h0, 7h0};
        
        counter.d = 0;    //clock counter is reset to 0 in manual mode
        if (io_button[1] == 1){     //pressing "CENTER" button starts auto testing
          state.d = state.ADDER1; 
        }
  
      state.ADDER1:
        alu.alufn = Inst.ADD;              //selects addition operation of alu
        alu.op1 = 8b1;                //input op1 = 1
        alu.op2 = 8b1;                //input a = 1
        text = {"a","d","d",7b1};     //displays "add" to show testing of ADDER
        counter.d = counter.q+1;      //continually increases clock counter until delay time is over
        
        if (counter.q[DELAY]==1&&alu.out==8b10){ //wait for counter to hit specified value, then check if output is correct
          counter.d = 0;                         //reset counter value to 0
          state.d = state.ADDER2;            //welp! Next test
     
        }else if (counter.q[DELAY] == 1 && alu.out!= 8b10){ // Oh man, results are wrong!
          counter.d=0;                                //reset counter value to 0
          state.d=state.ADDER_ERR;
        }                   //move to adder error state
           
      state.ADDER2:
        alu.alufn = Inst.ADD;          
        alu.op1 = 8b10000000;
        alu.op2 = 8b1;
        text = {"a","d","d",7b10};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b10000001 && alu.nOut ==8b1){  //n==1, out is negative
          counter.d = 0;
          state.d = state.ADDER3;
        }else if (counter.q[DELAY] == 1 && (alu.out != 8b10000001 || alu.nOut !=8b1)){
          counter.d = 0;
          state.d = state.ADDER_ERR;
        }
        
       state.ADDER3:
        alu.alufn = Inst.ADD;          
        alu.op1 = 8b11111111;
        alu.op2 = 8b1;
        text = {"a","d","d",7b11};
        counter.d = counter.q+1;

                
        if (counter.q[DELAY]==1 && alu.out == 8b0 && alu.zOut ==8b1){   //z==1, out is all zero
          counter.d = 0;
          state.d = state.ADDER4;
        }else if (counter.q[DELAY] == 1 && (alu.out != 8b0 || alu.zOut !=8b1)){
          counter.d = 0;
          state.d = state.ADDER_ERR;
        } 
        
       state.ADDER4:
        alu.alufn = Inst.ADD;          
        alu.op1 = 8b1111111;
        alu.op2 = 8b1;
        text = {"a","d","d",7b100};
        counter.d = counter.q+1;

                
        if (counter.q[DELAY]==1 && alu.out == 8b11111111 && alu.vOut ==8b1){  //v==1, overflow
          counter.d = 0;
          state.d = state.ADDER4;
        }else if (counter.q[DELAY] == 1 && (alu.out != 8b11111111 || alu.vOut !=8b1)){
          counter.d = 0;
          state.d = state.ADDER_ERR;
        } 
                
       state.ADDER_ERR:
        alu.alufn = Inst.ADD;
        alu.op1 = 8b0;
        alu.op2 = 8b0;
        text = {"e","a","d","d"};
        
        
      state.SUB1:
        alu.alufn = Inst.SUB;              //selects subtraction operation of alu
        alu.op1 = 8b10;                //input op1 = 2
        alu.op2 = 8b1;                //input op2 = 1
        text = {"s","u","b",7b1};     //displays "sub" to show testing of SUB
        counter.d = counter.q+1;      //continually increases clock counter until delay time is over
        
        if (counter.q[DELAY]==1&&alu.out==8b1){ //wait for counter to hit specified value, then check if output is correct
          counter.d = 0;                         //reset counter value to 0
          state.d = state.SUB2;            //welp! Next test
     
        }else if (counter.q[DELAY] == 1 && alu.out!= 8b1){ // Oh man, results are wrong!
          counter.d=0;                                //reset counter value to 0
          state.d=state.SUB_ERR;
        }                   //move to error state
           
      state.SUB2:
        alu.alufn = Inst.SUB;          
        alu.op1 = 8b10000001;
        alu.op2 = 8b1;
        text = {"s","u","b",7b10};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b10000000 && alu.nOut ==8b1){  //n==1, out is negative
          counter.d = 0;
          state.d = state.SUB3;
        }else if (counter.q[DELAY] == 1 && (alu.out != 8b10000000 || alu.nOut !=8b1)){
          counter.d = 0;
          state.d = state.SUB_ERR;
        }
        
       state.SUB3:
        alu.alufn = Inst.SUB;          
        alu.op1 = 8b1;
        alu.op2 = 8b1;
        text = {"s","u","b",7b11};
        counter.d = counter.q+1;

                
        if (counter.q[DELAY]==1 && alu.out == 8b0 && alu.zOut ==8b1){   //z==1, out is all zero
          counter.d = 0;
          state.d = state.ADDER4;
        }else if (counter.q[DELAY] == 1 && (alu.out != 8b0 || alu.zOut !=8b1)){
          counter.d = 0;
          state.d = state.ADDER_ERR;
        } 
        
       state.SUB4:
        alu.alufn = Inst.SUB;          
        alu.op1 = 8b10000000;
        alu.op2 = 8b1;
        text = {"s","u","b",7b100};
        counter.d = counter.q+1;

                
        if (counter.q[DELAY]==1 && alu.out == 8b1111111 && alu.vOut ==8b1){  //v==1, overflow
          counter.d = 0;
          state.d = state.SUB4;
        }else if (counter.q[DELAY] == 1 && (alu.out != 8b11111111 || alu.vOut !=8b1)){
          counter.d = 0;
          state.d = state.SUB_ERR;
        } 
                
       state.SUB_ERR:
        alu.alufn = Inst.SUB;
        alu.op1 = 8b0;
        alu.op2 = 8b0;
        text = {"e","s","u","b"};
        
        
      state.AND1:
        alu.alufn = Inst.AND;        
        alu.op1 = 8b1;                         
        alu.op2 = 8b1;
        text = {"a","n","d",7b1};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b1){
          counter.d = 0;
          state.d = state.AND2;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b1){
          counter.d = 0;
          state.d = state.AND_ERR;
        }
      state.AND2:
        alu.alufn = Inst.AND;        
        alu.op1 = 8b0;
        alu.op2 = 8b0;
        text = {"a","n","d",7b10};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b0){
          counter.d = 0;
          state.d = state.AND3;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b0){
          counter.d = 0;
          state.d = state.AND_ERR;
        }
        
      state.AND3:
        alu.alufn = Inst.AND;        
        alu.op1 = 8b1;
        alu.op2 = 8b0;
        text = {"a","n","d",7b11};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b0){
          counter.d = 0;
          state.d = state.OR;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b1){
          counter.d = 0;
          state.d = state.AND_ERR;
        }
        
      state.AND_ERR:
        alu.alufn = Inst.AND;
        alu.op1 = 8b1;
        alu.op2 = 8b1;
        text = {"e","a","n","d"};
        
        
       state.OR:
        alu.alufn = Inst.OR;         
        alu.op1 = 8b0;
        alu.op2 = 8b1;
        text = {"s","u","b","z"};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b1){
          counter.d = 0;
          state.d = state.OR2;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b1){
          counter.d = 0;
          state.d = state.OR_ERR;
        }
        
       state.OR2:
        alu.alufn = Inst.OR;         
        alu.op1 = 8b0;
        alu.op2 = 8b0;
        text = {"s","u","b",7b10};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b0){
          counter.d = 0;
          state.d = state.XOR;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b0){
          counter.d = 0;
          state.d = state.OR_ERR;
        }
        
      state.OR_ERR:
        alu.alufn = Inst.OR;
        alu.op1 = 8b1;
        alu.op2 = 8b1;
        text = {"e","o","r","z"};
        
        
      state.XOR:
        alu.alufn = Inst.XOR;         
        alu.op1 = 8b0;
        alu.op2 = 8b1;
        text = {"h","o","r","z"};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b1){
          counter.d = 0;
          state.d = state.XOR2;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b1){
          counter.d = 0;
          state.d = state.XOR_ERR;
        }
        
      state.XOR2:
        alu.alufn = Inst.XOR;         
        alu.op1 = 8b1;
        alu.op2 = 8b1;
        text = {"h","o","r",7b10};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b0){
          counter.d = 0;
          state.d = state.INV;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b0){
          counter.d = 0;
          state.d = state.XOR_ERR;
        }
        
      state.XOR_ERR:
        alu.alufn = Inst.XOR;
        alu.op1 = 8b1;
        alu.op2 = 8b1;
        text = {"e","h","o","r"};
        
        
      state.INV:
        alu.alufn = Inst.INV;         
        alu.op1 = 8b0;
        text = {7b1,"n","u","z"};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b1){
          counter.d = 0;
          state.d = state.LDR;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b1){
          counter.d = 0;
          state.d = state.INV_ERR;
        }
        
      state.INV_ERR:
        alu.alufn = Inst.INV;
        alu.op1 = 8b1;
        text = {"e",7b1,"n","u"};
        
      state.LDR:
        alu.alufn = Inst.LDR;         
        alu.op1 = 8b10;
        text = {"l","d","r","z"};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b10){
          counter.d = 0;
          state.d = state.SHL;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b10){
          counter.d = 0;
          state.d = state.LDR_ERR;
        }
        
      state.LDR_ERR:
        alu.alufn = Inst.INV;
        alu.op1 = 8b10;
        text = {"e","l","d","r"};
        
        
      state.SHL:
        alu.alufn = Inst.SHL;        
        alu.op1 = 8b11;                                       // positve number
        alu.op2 = 8b1;
        text = {"s","h","l","z"};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b110){
          counter.d = 0;
          state.d = state.SHL2;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b110){
          counter.d = 0;
          state.d = state.SHL_ERR;
        }
        
      state.SHL2:                               
        alu.alufn = Inst.SHL;        
        alu.op1 = 8b11111111;                                 // negative number
        alu.op2 = 8b1;
        text = {"s","h","l",7b10};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b11111110){
          counter.d = 0;
          state.d = state.SHR;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b11111110){
          counter.d = 0;
          state.d = state.SHL_ERR;
        }
        
      state.SHL_ERR:
        alu.alufn = Inst.SHL;
        alu.op1 = 8b11;                                       
        alu.op2 = 8b1;
        text = {"e","s","h","l"};
        
        
      state.SHR:
        alu.alufn = Inst.SHR;        
        alu.op1 = 8b11;                                       // positve number
        alu.op2 = 8b1;
        text = {"s","h","r","z"};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b1){
          counter.d = 0;
          state.d = state.SHR2;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b1){
          counter.d = 0;
          state.d = state.SHR_ERR;
        }
        
      state.SHR2:
        alu.alufn = Inst.SRA;        
        alu.op1 = 8b11000000;                                 // negative number
        alu.op2 = 8b1;
        text = {"s","h","r",7b10};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b1100000){
          counter.d = 0;
          state.d = state.SHR;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b1100000){
          counter.d = 0;
          state.d = state.SHR_ERR;
        }
        
      state.SHR_ERR:
        alu.alufn = Inst.SHR;
        alu.op1 = 8b11;
        alu.op2 = 8b1;
        text = {"e","s","h","r"};
        
        
      state.SRA:
        alu.alufn = Inst.SRA;        
        alu.op1 = 8b101;                                       // positve number
        alu.op2 = 8b1;
        text = {"s","r","a","z"};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b10){
          counter.d = 0;
          state.d = state.SRA2;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b10){
          counter.d = 0;
          state.d = state.SRA_ERR;
        }
        
      state.SRA2:
        alu.alufn = Inst.SRA;        
        alu.op1 = 8b10100000;                                 // negative number
        alu.op2 = 8b1;
        text = {"s","r","a",7b10};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b11010000){
          counter.d = 0;
          state.d = state.CMPEQ;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b11010000){
          counter.d = 0;
          state.d = state.SRA_ERR;
        }
        
      state.SRA_ERR:
        alu.alufn = Inst.SRA;
        alu.op1 = 8b101;
        alu.op2 = 8b1;
        text = {"e","s","r","a"};
        
      state.CMPEQ:
        alu.alufn = Inst.CMPEQ;        
        alu.z = 8b0;
        text = {"c","p","e","o"};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b0){
          counter.d = 0;
          state.d = state.CMPLT;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b0){
          counter.d = 0;
          state.d = state.EQ_ERR;
        }
        
      state.EQ_ERR:
        alu.alufn = Inst.CMPEQ;
        alu.z= 8b0;
        text = {"e","c","p","o"};
        
      state.CMPLT:
        alu.alufn = Inst.CMPLT;        
        alu.n = 8b0;
        alu.v = 8b1;
        text = {"c","p","l","t"};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b1){
          counter.d = 0;
          state.d = state.CMPLE;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b1){
          counter.d = 0;
          state.d = state.LT_ERR;
        }
        
      state.LT_ERR:
        alu.alufn = Inst.CMPLT;
        alu.n= 8b0;
        alu.v = 8b1;
        text = {"e","c","p","t"};
        
      state.CMPLE:
        alu.alufn = Inst.CMPLE;  
        alu.z= 8b0;      
        alu.n = 8b0;
        alu.v = 8b1;
        text = {"c","p","l","t"};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b0){
          counter.d = 0;
          state.d = state.MUL;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b0){
          counter.d = 0;
          state.d = state.LT_ERR;
        }
        
      state.LE_ERR:
        alu.alufn = Inst.CMPLE;
        alu.z = 8b0;
        alu.n= 8b0;
        alu.v = 8b1;
        text = {"e","c","p","e"};
        
        
      state.MUL:
        alu.alufn = Inst.MUL;  
        alu.op1= 8b10;      
        alu.op2 = 8b10;
        text = {"n","u","l","z"};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b100){
          counter.d = 0;
          state.d = state.MUL2;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b100){
          counter.d = 0;
          state.d = state.MUL_ERR;
        }
      state.MUL2:
        alu.alufn = Inst.MUL;  
        alu.op1= 8b0;      
        alu.op2 = 8b10;
        text = {"n","u","l",7b10};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b0){
          counter.d = 0;
          state.d = state.MUL3;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b0){
          counter.d = 0;
          state.d = state.MUL_ERR;
        }
      state.MUL3:
        alu.alufn = Inst.MUL;  
        alu.op1= 8b11111111;      
        alu.op2 = 8b11111111;
        text = {"n","u","l",7b11};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b1){
          counter.d = 0;
          state.d = state.NEG;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b1){
          counter.d = 0;
          state.d = state.MUL_ERR;
        }
        
        
      state.MUL_ERR:
        alu.alufn = Inst.MUL;
        alu.op1 = 8b10;
        alu.op2 = 8b10;
        text = {"e","n","u","l"};
        
        
     state.NEG:
        alu.alufn = Inst.NEG;  
        alu.op1 = 8b1;      
        text = {"n","e",7b110,"z"};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b11111111){
          counter.d = 0;
          state.d = state.ABS;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b0){
          counter.d = 0;
          state.d = state.NEG_ERR;
        }
        
      state.NEG_ERR:
        alu.alufn = Inst.NEG;
        alu.op1 = 8b1;
        text = {"e","n","e",7b110};
        
        
        
      state.ABS:
        alu.alufn = Inst.ABS;  
        alu.op1 = 8b11111111;      
        text = {"a","b","s","z"};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b1){
          counter.d = 0;
          state.d = state.MANUAL;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b1){
          counter.d = 0;
          state.d = state.ABS_ERR;
        }
       state.ABS2:
        alu.alufn = Inst.ABS;  
        alu.op1 = 8b1111111;      
        text = {"a","b","s",7b10};
        counter.d = counter.q+1;
        
        if (counter.q[DELAY]==1 && alu.out == 8b10000001){
          counter.d = 0;
          state.d = state.MANUAL;
        }else if (counter.q[DELAY] == 1 && alu.out != 8b10000001){
          counter.d = 0;
          state.d = state.ABS_ERR;
        }
      state.ABS_ERR:
        alu.alufn = Inst.ABS;
        alu.op1 = 8b11111111;
        text = {"e","a","b","s"};   
        
    }
  }
}
